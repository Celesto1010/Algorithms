"""
单调栈。用于求解y一个序列中每个元素左边或右边第一个比其大或小的元素
在栈的【先进后出】规则基础上，要求：从栈顶到栈底的元素是单调递增/递减的。

单调递增栈：栈顶到栈底的元素单调递增。入栈时，若当前元素比栈顶元素大，则弹出，直到当前元素比栈顶元素小，将当前元素入栈。
单调递减栈：栈顶到栈底的元素单调递减。入栈时，若当前元素比栈顶元素小，则弹出，直到当前元素比栈顶元素大，将当前元素入栈。

查找比当前元素大的元素，就用单调递增栈，否则用单调递减栈。
查找左侧的元素，看【插入栈】时的栈顶元素；查找右侧的元素，看【弹出栈】时即将插入的元素

通用代码模板：
for 元素 in 列表:
    while 栈不为空 and 栈顶元素（大于或者小于）目标值：
        出栈
        根据业务处理
    入栈
"""


def next_larger_element(array):
    """ 对于列表中的每一个元素，寻找其右边的第一个更大的元素。若不存在，则置-1 """
    # 单调递增栈：用于找到下一个更大的元素。stack中记录元素下标
    stack = list()
    # 维护元素的下一个更大元素
    ret = [-1] * len(array)

    for index in range(len(array)):
        num = array[index]
        # 若栈顶元素更小，说明当前元素的值就是栈顶元素的右边第一个更大的元素。弹出栈顶元素，修改原栈顶元素索引对应的值为当前元素的值。
        while stack and array[stack[-1]] < num:
            origin_index = stack.pop()
            # 通过原元素的索引来保存下一个更大元素
            ret[origin_index] = num
        # 直到栈顶元素更大，将当前索引入栈，维持栈内的单调递增性。
        stack.append(index)
    return ret


if __name__ == '__main__':
    print(next_larger_element([4, 2, 3, 9, 5, 0, 1, 6, 4, 8]))